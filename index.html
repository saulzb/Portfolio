<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Saul Zidulka-Bejcek</title>
<style>
html,body{
  margin:0; padding:0;
  height:100%;
  font-family:Arial, sans-serif;
  overflow-y:scroll;
  scroll-snap-type:y mandatory;
}

section{
  height:100vh;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  scroll-snap-align:start;
  position:relative;
  text-align:center;
  overflow:hidden;
}

/* HERO */
.hero{ position:relative; color:black; z-index:0; }
.hero video{
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  object-fit:cover;
  z-index:-2;
}

/* Canvas on top of hero for letters + spotlight */
#heroCanvas{
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  pointer-events:none;
  z-index:1;
}

/* ABOUT & CONTACT */
.about{ background:#222; color:white; position:relative; }
.contact{ background:#eee; color:#111; position:relative; }

/* Canvas for bubbles */
#bubbleCanvas{
  position:absolute; left:0; top:0;
  width:100%; height:100%;
  z-index:0;
  pointer-events:none;
}

.interactive-word{ display:inline-block; position:relative; }
nav a{ color:black; font-weight:bold; margin:0 15px; text-decoration:none; }
nav a:hover{ color:orange; }
</style>
</head>
<body>

<!-- HERO -->
<section class="hero">
  <video autoplay muted loop playsinline>
    <source src="1757373621.967906.MOV" type="video/mp4">
  </video>

  <!-- Canvas for letters + spotlight -->
  <canvas id="heroCanvas"></canvas>

  <!-- Actual letters (clickable) -->
  <h1 class="interactive-word" id="title">SAUL ZIDULKA-BEJCEK</h1>
  <nav>
    <a href="photos/photoholder.html" class="interactive-word" id="photos">PHOTOS</a>
    <a href="drawings.html" class="interactive-word" id="drawings">DRAWINGS</a>
  </nav>
</section>

<!-- ABOUT -->
<section class="about" id="about-section">
  <h2 class="interactive-word">ABOUT</h2>
  <p class="interactive-word">All art by Saul Zidulka-Bejcek. Based in the Pacific Northwest.</p>
  <canvas id="bubbleCanvas" aria-hidden="true"></canvas>
</section>

<!-- CONTACT -->
<section class="contact">
  <h2 class="interactive-word">CONTACT</h2>
  <p>Email: <a href="mailto:saulzb@hotmail.com">saulzb@hotmail.com</a></p>
  <p>Instagram: <a href="https://www.instagram.com/saul_5607/" target="_blank">@saul_5607</a></p>
</section>

<script>
/* ---------- HERO LETTERS + SPOTLIGHT ---------- */
const heroCanvas = document.getElementById('heroCanvas');
const hCtx = heroCanvas.getContext('2d');
let heroWidth=0, heroHeight=0;

function resizeHeroCanvas(){
  heroWidth = window.innerWidth;
  heroHeight = window.innerHeight;
  heroCanvas.width = heroWidth;
  heroCanvas.height = heroHeight;
}
window.addEventListener('resize', resizeHeroCanvas);
resizeHeroCanvas();

// Grab actual HTML elements
const elements = [
  document.getElementById('title'),
  document.getElementById('photos'),
  document.getElementById('drawings')
];

function getLetterPositions(){
  return elements.map(el=>{
    const rect = el.getBoundingClientRect();
    return {
      text: el.innerText,
      x: rect.left + rect.width/2,
      y: rect.top + rect.height/2,
      width: rect.width,
      height: rect.height,
      fontSize: parseInt(window.getComputedStyle(el).fontSize)
    };
  });
}

let letterPositions = getLetterPositions();
window.addEventListener('resize', ()=>{ letterPositions = getLetterPositions(); });

/* spotlight position */
let spotX = heroWidth/2;
let spotY = heroHeight/2;
let dx = 1, dy = 0.8;
const SPOT_RADIUS = 120;

function animateHero(){
  hCtx.clearRect(0,0,heroWidth,heroHeight);

  // Draw letters in black (canvas only for spotlight)
  letterPositions.forEach(l=>{
    hCtx.font = `bold ${l.fontSize}px Arial`;
    hCtx.textAlign = "center";
    hCtx.textBaseline = "middle";
    hCtx.fillStyle = "black";
    hCtx.fillText(l.text, l.x, l.y);
  });

  // Update spotlight within letter bounding rectangle area
  const minX = Math.min(...letterPositions.map(l=>l.x-l.width/2));
  const maxX = Math.max(...letterPositions.map(l=>l.x+l.width/2));
  const minY = Math.min(...letterPositions.map(l=>l.y-l.height/2));
  const maxY = Math.max(...letterPositions.map(l=>l.y+l.height/2));

  spotX += dx; spotY += dy;
  if(spotX<minX+SPOT_RADIUS || spotX>maxX-SPOT_RADIUS) dx*=-1;
  if(spotY<minY+SPOT_RADIUS || spotY>maxY-SPOT_RADIUS) dy*=-1;

  // Draw radial gradient spotlight on top of letters only
  hCtx.save();
  hCtx.globalCompositeOperation = 'source-atop';
  const grad = hCtx.createRadialGradient(spotX,spotY,0, spotX,spotY,SPOT_RADIUS);
  grad.addColorStop(0,'rgba(255,255,255,0.9)');
  grad.addColorStop(0.3,'rgba(255,140,0,0.6)');
  grad.addColorStop(1,'rgba(0,0,0,0)');
  hCtx.fillStyle = grad;
  hCtx.fillRect(0,0,heroWidth,heroHeight);
  hCtx.restore();

  requestAnimationFrame(animateHero);
}
animateHero();

/* ---------- ABOUT BUBBLES ---------- */
const aboutSection = document.getElementById('about-section');
const bubbleCanvas = document.getElementById('bubbleCanvas');
const ctx = bubbleCanvas.getContext('2d');
let viewW=0, viewH=0, dpr=window.devicePixelRatio||1;

function resizeCanvas(){
  const rect = aboutSection.getBoundingClientRect();
  const w = Math.max(100, Math.floor(rect.width));
  const h = Math.max(100, Math.floor(rect.height));
  viewW = w; viewH = h;
  bubbleCanvas.style.width = w+'px';
  bubbleCanvas.style.height = h+'px';
  bubbleCanvas.width = Math.floor(w*dpr);
  bubbleCanvas.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',()=>setTimeout(resizeCanvas,0));
resizeCanvas();

let words = Array.from(aboutSection.querySelectorAll('.interactive-word'));
const bubbles = [];
const NUM = 40;

function initBubbles(){
  bubbles.length=0;
  for(let i=0;i<NUM;i++){
    const hue = Math.random()*60 + 180;
    bubbles.push({
      x: Math.random()*viewW,
      y: Math.random()*viewH,
      vx: (Math.random()-0.5)*0.2,
      vy: (Math.random()-0.5)*0.2 -0.2,
      size: Math.random()*18+10,
      color: `hsla(${hue},70%,50%,${Math.random()*0.4 +0.18})`
    });
  }
}
initBubbles();

const mouse = { x:viewW/2, y:viewH/2, moving:false };
aboutSection.addEventListener('mousemove',e=>{
  const r = bubbleCanvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left;
  mouse.y = e.clientY - r.top;
  mouse.moving = true;
  clearTimeout(mouse.timer);
  mouse.timer = setTimeout(()=>{ mouse.moving=false; },700);
});

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function resolveBubbleRectCollision(b,left,top,right,bottom){
  const closestX = clamp(b.x,left,right);
  const closestY = clamp(b.y,top,bottom);
  let dx = b.x-closestX, dy=b.y-closestY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist<b.size){
    const safeDist = dist || 0.0001;
    const overlap = b.size-dist;
    const nx=dx/safeDist, ny=dy/safeDist;
    b.x += nx*overlap; b.y += ny*overlap;
    const PUSH=0.45; b.vx+=nx*PUSH; b.vy+=ny*PUSH;
  }
}

function updateBubbles(){
  if(viewW===0||viewH===0){ requestAnimationFrame(updateBubbles); return; }
  ctx.clearRect(0,0,viewW,viewH);

  for(let i=0;i<bubbles.length;i++){
    const a = bubbles[i];
    for(let j=i+1;j<bubbles.length;j++){
      const b = bubbles[j];
      const dx = b.x-a.x, dy = b.y-a.y;
      const dist = Math.sqrt(dx*dx + dy*dy)||1;
      const minD = a.size+b.size;
      if(dist<minD){
        const overlap=minD-dist;
        const nx=dx/dist, ny=dy/dist, push=overlap*0.03;
        a.vx-=nx*push; a.vy-=ny*push;
        b.vx+=nx*push; b.vy+=ny*push;
      }
    }
  }

  words = Array.from(aboutSection.querySelectorAll('.interactive-word'));
  const canvasRect = bubbleCanvas.getBoundingClientRect();

  for(const b of bubbles){
    if(mouse.moving){ b.vx += (mouse.x-b.x)*0.0012; b.vy += (mouse.y-b.y)*0.0012; }
    else { b.vx += (Math.random()-0.5)*0.01; b.vy -= 0.02; }

    for(const w of words){
      const r=w.getBoundingClientRect();
      const left=r.left-canvasRect.left;
      const top=r.top-canvasRect.top;
      const right=left+r.width;
      const bottom=top+r.height;
      resolveBubbleRectCollision(b,left,top,right,bottom);
    }

    b.x+=b.vx; b.y+=b.vy;

    if(b.y+b.size<0)b.y=viewH+b.size;
    if(b.y-b.size>viewH)b.y=-b.size;

    if(b.x-b.size<0){ b.x=b.size; b.vx*=-0.45; }
    if(b.x+b.size>viewW){ b.x=viewW-b.size; b.vx*=-0.45; }

    b.vx*=0.95; b.vy*=0.95;

    ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2);
    ctx.fillStyle=b.color; ctx.fill();
  }

  requestAnimationFrame(updateBubbles);
}
updateBubbles();

/* Reset bubbles when About section comes back into view */
const observer = new IntersectionObserver(entries=>{
  entries.forEach(entry=>{ if(entry.isIntersecting){ initBubbles(); } });
},{ threshold:0.4 });
observer.observe(aboutSection);
</script>
</body>
</html>
