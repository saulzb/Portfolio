<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Saul Zidulka-Bejcek</title>
<style>
html,body{
  margin:0; padding:0;
  height:100%;
  font-family:Arial, sans-serif;
  overflow-y:scroll;
  scroll-snap-type:y mandatory;
}

section{
  height:100vh;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  scroll-snap-align:start;
  position:relative;
  text-align:center;
  overflow:hidden;
}

/* HERO */
.hero{ position:relative; color:black; z-index:0; }
.hero video{
  position:absolute; top:0; left:0;
  width:100%; height:100%;
  object-fit:cover;
  z-index:-2;
}

/* Canvas on top of hero for letters + spotlight */
#heroCanvas{
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  pointer-events:none;
  z-index:1;
}

/* Actual HTML letters (clickable) on top */
.hero-text {
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  display:flex;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  pointer-events:auto;
  z-index:2;
}

.hero-text a, .hero-text h1 {
  margin:10px;
  color:black;
  font-weight:bold;
  font-family:Arial,sans-serif;
  text-decoration:none;
  position:relative;
}

/* ABOUT & CONTACT */
.about{ background:#222; color:white; position:relative; }
.contact{ background:#eee; color:#111; position:relative; }

/* Canvas for bubbles */
#bubbleCanvas{
  position:absolute; left:0; top:0;
  width:100%; height:100%;
  z-index:0;
  pointer-events:none;
}

.interactive-word{ display:inline-block; position:relative; }
</style>
</head>
<body>

<!-- HERO -->
<section class="hero">
  <video autoplay muted loop playsinline>
    <source src="1757373621.967906.MOV" type="video/mp4">
  </video>

  <canvas id="heroCanvas"></canvas>

  <!-- Actual clickable text -->
  <div class="hero-text">
    <h1 class="interactive-word">SAUL ZIDULKA-BEJCEK</h1>
    <nav>
      <a href="photos/photoholder.html" class="interactive-word">PHOTOS</a>
      <a href="drawings.html" class="interactive-word">DRAWINGS</a>
    </nav>
  </div>
</section>

<!-- ABOUT -->
<section class="about" id="about-section">
  <h2 class="interactive-word">ABOUT</h2>
  <p class="interactive-word">All art by Saul Zidulka-Bejcek. Based in the Pacific Northwest.</p>
  <canvas id="bubbleCanvas" aria-hidden="true"></canvas>
</section>

<!-- CONTACT -->
<section class="contact">
  <h2 class="interactive-word">CONTACT</h2>
  <p>Email: <a href="mailto:saulzb@hotmail.com">saulzb@hotmail.com</a></p>
  <p>Instagram: <a href="https://www.instagram.com/saul_5607/" target="_blank">@saul_5607</a></p>
</section>

<script>
/* ---------- HERO LETTERS + SPOTLIGHT ---------- */
const heroCanvas = document.getElementById('heroCanvas');
const hCtx = heroCanvas.getContext('2d');
let heroWidth = window.innerWidth;
let heroHeight = window.innerHeight;

function resizeHeroCanvas() {
  heroWidth = window.innerWidth;
  heroHeight = window.innerHeight;
  heroCanvas.width = heroWidth;
  heroCanvas.height = heroHeight;
}
window.addEventListener('resize', resizeHeroCanvas);
resizeHeroCanvas();

// Letter positions
const letterPositions = [
  {text:"SAUL ZIDULKA-BEJCEK", fontSize: heroWidth/18, x:heroWidth/2, y:heroHeight/2 - 50},
  {text:"PHOTOS", fontSize: heroWidth/28, x:heroWidth/3, y:heroHeight/2 + 20},
  {text:"DRAWINGS", fontSize: heroWidth/28, x:2*heroWidth/3, y:heroHeight/2 + 20}
];

function getLettersBounds() {
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  letterPositions.forEach(l => {
    hCtx.font = `bold ${l.fontSize}px Arial`;
    const metrics = hCtx.measureText(l.text);
    const w = metrics.width;
    const h = l.fontSize;
    minX = Math.min(minX, l.x - w/2);
    maxX = Math.max(maxX, l.x + w/2);
    minY = Math.min(minY, l.y - h/2);
    maxY = Math.max(maxY, l.y + h/2);
  });
  return {minX, maxX, minY, maxY};
}

let bounds = getLettersBounds();
let spotX = (bounds.minX+bounds.maxX)/2;
let spotY = (bounds.minY+bounds.maxY)/2;
let dx = 0;
let dy = 0;
let targetX = spotX, targetY = spotY;
const SPOT_RADIUS = 80;

function animateHeroSpotlight() {
  hCtx.clearRect(0,0,heroWidth,heroHeight);

  // Draw black letters
  letterPositions.forEach(l=>{
    hCtx.font = `bold ${l.fontSize}px Arial`;
    hCtx.textAlign = "center";
    hCtx.textBaseline = "middle";
    hCtx.fillStyle = "black";
    hCtx.fillText(l.text, l.x, l.y);
  });

  // Move spotlight smoothly toward target
  spotX += (targetX - spotX) * 0.05;
  spotY += (targetY - spotY) * 0.05;

  // Change target occasionally
  if(Math.random()<0.01){
    targetX = bounds.minX + Math.random()*(bounds.maxX-bounds.minX);
    targetY = bounds.minY + Math.random()*(bounds.maxY-bounds.minY);
  }

  // Draw spotlight only on letters
  hCtx.save();
  hCtx.globalCompositeOperation = 'source-atop';
  const grad = hCtx.createRadialGradient(spotX, spotY, 0, spotX, spotY, SPOT_RADIUS);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.3, 'rgba(255,140,0,0.6)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  hCtx.fillStyle = grad;

  letterPositions.forEach(l=>{
    hCtx.font = `bold ${l.fontSize}px Arial`;
    hCtx.textAlign = "center";
    hCtx.textBaseline = "middle";
    hCtx.fillText(l.text, l.x, l.y);
  });

  hCtx.fillRect(0,0,heroWidth,heroHeight);
  hCtx.restore();

  requestAnimationFrame(animateHeroSpotlight);
}
animateHeroSpotlight();

/* ---------- ABOUT BUBBLES ---------- */
const aboutSection = document.getElementById('about-section');
const bubbleCanvas = document.getElementById('bubbleCanvas');
const ctx = bubbleCanvas.getContext('2d');
let viewW=0, viewH=0, dpr=window.devicePixelRatio||1;

function resizeCanvas(){
  const rect = aboutSection.getBoundingClientRect();
  viewW = Math.max(100, Math.floor(rect.width));
  viewH = Math.max(100, Math.floor(rect.height));
  bubbleCanvas.style.width = viewW+'px';
  bubbleCanvas.style.height = viewH+'px';
  bubbleCanvas.width = Math.floor(viewW*dpr);
  bubbleCanvas.height = Math.floor(viewH*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize',()=>setTimeout(resizeCanvas,0));
resizeCanvas();

let words = Array.from(aboutSection.querySelectorAll('.interactive-word'));
const bubbles = [];
const NUM = 40;

function initBubbles(){
  bubbles.length=0;
  for(let i=0;i<NUM;i++){
    const hue = Math.random()*60 + 180;
    bubbles.push({
      x: Math.random()*viewW,
      y: Math.random()*viewH,
      vx: (Math.random()-0.5)*0.2,
      vy: (Math.random()-0.5)*0.2 -0.2,
      size: Math.random()*18+10,
      color: `hsla(${hue},70%,50%,${Math.random()*0.4 +0.18})`
    });
  }
}
initBubbles();

const mouse = { x:viewW/2, y:viewH/2, moving:false };
aboutSection.addEventListener('mousemove',e=>{
  const r = bubbleCanvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left;
  mouse.y = e.clientY - r.top;
  mouse.moving = true;
  clearTimeout(mouse.timer);
  mouse.timer = setTimeout(()=>{ mouse.moving=false; },700);
});

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function resolveBubbleRectCollision(b,left,top,right,bottom){
  const closestX = clamp(b.x,left,right);
  const closestY = clamp(b.y,top,bottom);
  let dx = b.x-closestX, dy = b.y-closestY;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if(dist<b.size){
    const safeDist = dist || 0.0001;
    const overlap = b.size-dist;
    const nx=dx/safeDist, ny=dy/safeDist;
    b.x += nx*overlap; b.y += ny*overlap;
    const PUSH=0.45; b.vx+=nx*PUSH; b.vy+=ny*PUSH;
  }
}

function updateBubbles(){
  if(viewW===0||viewH===0){ requestAnimationFrame(updateBubbles); return; }
  ctx.clearRect(0,0,viewW,viewH);

  for(let i=0;i<bubbles.length;i++){
    const a = bubbles[i];
    for(let j=i+1;j<bubbles.length;j++){
      const b = bubbles[j];
      const dx = b.x-a.x, dy = b.y-a.y;
      const dist = Math.sqrt(dx*dx + dy*dy)||1;
      const minD = a.size+b.size;
      if(dist<minD){
        const overlap=minD-dist;
        const nx=dx/dist, ny=dy/dist, push=overlap*0.03;
        a.vx-=nx*push; a.vy-=ny*push;
        b.vx+=nx*push; b.vy+=ny*push;
      }
    }
  }

  words = Array.from(aboutSection.querySelectorAll('.interactive-word'));
  const canvasRect = bubbleCanvas.getBoundingClientRect();

  for(const b of bubbles){
    if(mouse.moving){ b.vx += (mouse.x-b.x)*0.0012; b.vy += (mouse.y-b.y)*0.0012; }
    else { b.vx += (Math.random()-0.5)*0.01; b.vy -= 0.02; }

    for(const w of words){
      const r=w.getBoundingClientRect();
      const left=r.left-canvasRect.left;
      const top=r.top-canvasRect.top;
      const right=left+r.width;
      const bottom=top+r.height;
      resolveBubbleRectCollision(b,left,top,right,bottom);
    }

    b.x+=b.vx; b.y+=b.vy;

    if(b.y+b.size<0)b.y=viewH+b.size;
    if(b.y-b.size>viewH)b.y=-b.size;

    if(b.x-b.size<0){ b.x=b.size; b.vx*=-0.45; }
    if(b.x+b.size>viewW){ b.x=viewW-b.size; b.vx*=-0.45; }

    b.vx*=0.95; b.vy*=0.95;

    ctx.beginPath(); ctx.arc(b.x,b.y,b.size,0,Math.PI*2);
    ctx.fillStyle=b.color; ctx.fill();
  }

  requestAnimationFrame(updateBubbles);
}
updateBubbles();

const observer = new IntersectionObserver(entries=>{
  entries.forEach(entry=>{ if(entry.isIntersecting){ initBubbles(); } });
},{ threshold:0.4 });
observer.observe(aboutSection);
</script>
</body>
</html>
