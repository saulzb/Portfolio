<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Saul Zidulka-Bejcek</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
    font-family: Arial, sans-serif;
  }

  section {
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    scroll-snap-align: start;
    text-align: center;
    position: relative;
  }

  /* Video hero section */
  .hero {
    position: relative;
    color: white;
  }
  .hero video {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: -1;
  }
  .hero h1 {
    font-size: 3rem;
    margin-bottom: 20px;
  }
  nav a {
    margin: 0 15px;
    text-decoration: none;
    color: white;
    font-weight: bold;
    transition: color 0.3s ease;
  }
  nav a:hover {
    color: lightblue;
    text-decoration: underline;
  }

  /* Other sections */
  .drawings {
    background: #222;
    color: white;
  }
  .contact {
    background: #eee;
    color: black;
  }

  /* Words to block blobs */
  .block-word {
    display: inline-block;
    position: relative;
    z-index: 2;
    font-weight: bold;
  }

  canvas {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1;
    pointer-events: none; /* blobs don’t block clicks */
  }
</style>
</head>
<body>

<section class="hero">
  <video autoplay muted loop playsinline>
    <source src="1757373621.967906.MOV" type="video/mp4">
  </video>
  <h1><span class="block-word">SAUL</span> <span class="block-word">ZIDULKA-BEJCEK</span></h1>
  <nav>
    <a href="photos/photoholder.html">PHOTOS</a>
    <a href="drawings.html">DRAWINGS</a>
  </nav>
</section>

<section class="drawings">
  <h2><span class="block-word">ABOUT</span></h2>
  <p>All art by <span class="block-word">Saul Zidulka-Bejcek</span>. Based in the Pacific Northwest.</p>
</section>

<section class="contact">
  <h2><span class="block-word">CONTACT</span></h2>
  <p>Email: <span class="block-word">saulzb@hotmail.com</span></p>
  <p>Instagram: <span class="block-word">@saul_5607</span></p>
</section>

<canvas id="bubbleCanvas"></canvas>

<script>
const canvas = document.getElementById('bubbleCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const bubbles = [];
const numBubbles = 30;
const colors = ['#00bfff', '#1e90ff', '#40e0d0', '#48d1cc']; // ocean/turquoise

const cursor = { x: width/2, y: height/2, lastX: width/2, lastY: height/2 };
let lastMoveTime = Date.now();

document.addEventListener('mousemove', e => {
  cursor.x = e.clientX;
  cursor.y = e.clientY;
  lastMoveTime = Date.now();
});

// Bubble class
class Bubble {
  constructor() {
    this.reset();
  }
  reset() {
    this.x = Math.random()*width;
    this.y = height + Math.random()*100;
    this.vx = (Math.random()-0.5)*0.5;
    this.vy = -1 - Math.random()*1;
    this.size = 10 + Math.random()*30;
    this.color = colors[Math.floor(Math.random()*colors.length)];
  }
  update(blockRects) {
    // Cursor attraction
    const dx = cursor.x - this.x;
    const dy = cursor.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < 150) {
      this.vx += (dx/dist)*0.05;
      this.vy += (dy/dist)*0.05;
    }

    // Slow random drift for “bubbling”
    this.vx += (Math.random()-0.5)*0.05;
    this.vy += (Math.random()-0.5)*0.02;

    // Interact with block words
    blockRects.forEach(rect => {
      const closestX = Math.max(rect.left, Math.min(this.x, rect.right));
      const closestY = Math.max(rect.top, Math.min(this.y, rect.bottom));
      const dx = this.x - closestX;
      const dy = this.y - closestY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < this.size+5) {
        const angle = Math.atan2(dy, dx);
        const force = (this.size+5 - dist)/10;
        this.vx += Math.cos(angle)*force;
        this.vy += Math.sin(angle)*force;
      }
    });

    // Interact with other bubbles
    bubbles.forEach(other => {
      if(other===this) return;
      const dx = this.x - other.x;
      const dy = this.y - other.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < this.size + other.size) {
        const angle = Math.atan2(dy, dx);
        const force = (this.size + other.size - dist)/20;
        this.vx += Math.cos(angle)*force*0.5;
        this.vy += Math.sin(angle)*force*0.5;
      }
    });

    // Drag larger bubbles slower
    this.x += this.vx*(30/this.size);
    this.y += this.vy*(30/this.size);

    // Slight friction
    this.vx *= 0.96;
    this.vy *= 0.96;

    // Reset if off top
    if(this.y+this.size < 0) this.reset();
  }
  draw() {
    ctx.beginPath();
    ctx.fillStyle = this.color + '88'; // translucent
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
  }
}

// Initialize bubbles
for(let i=0;i<numBubbles;i++) bubbles.push(new Bubble());

// Collect word rects
function getBlockRects() {
  const elements = document.querySelectorAll('.block-word');
  return Array.from(elements).map(el => el.getBoundingClientRect());
}

function animate() {
  ctx.clearRect(0,0,width,height);
  const blockRects = getBlockRects();

  // If cursor hasn't moved for 1.5s, make bubbles float up slowly
  const idle = (Date.now() - lastMoveTime) > 1500;
  if(idle){
    bubbles.forEach(b => {
      b.vy -= 0.02;
    });
  }

  bubbles.forEach(b => {
    b.update(blockRects);
    b.draw();
  });
  requestAnimationFrame(animate);
}

animate();

// Handle resize
window.addEventListener('resize', ()=>{
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});
</script>

</body>
</html>
